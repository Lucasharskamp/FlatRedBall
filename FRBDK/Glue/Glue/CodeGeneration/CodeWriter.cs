using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using FlatRedBall.Glue.CodeGeneration.CodeBuilder;
using FlatRedBall.IO;
using FlatRedBall.Utilities;
using FlatRedBall.Instructions.Reflection;
using FlatRedBall.Glue.Elements;
using FlatRedBall.Glue.SaveClasses;
using FlatRedBall.Glue.CodeGeneration;
using FlatRedBall.Glue.Events;
using FlatRedBall.Glue.Plugins.Performance;
using FlatRedBall.Glue.Plugins;
using FlatRedBall.Glue.Plugins.Interfaces;
using FlatRedBall.Glue.IO;
using System.IO;
using FlatRedBall.Glue.AutomatedGlue;
using FlatRedBall.Glue.Plugins.ExportedImplementations;
using System.Threading.Tasks;
using FlatRedBall.Glue.Managers;
using FlatRedBall.Glue.Plugins.EmbeddedPlugins.FactoryPlugin;

namespace FlatRedBall.Glue.Parsing;

#region Class Properties Struct

/// <summary>
/// Define the properties of a <see langword="class" /> to be generated.
/// </summary>
public struct ClassProperties
{
    /// <summary>
    /// The namespace the <see langword="class" /> belongs to.
    /// </summary>
    public string NamespaceName;

    /// <summary>
    /// The name of the <see langword="class" />.
    /// </summary>
    public string ClassName;

    /// <summary>
    /// The member fields and properties of the <see langword="class" />.
    /// </summary>
    public List<TypedMemberBase> Members;

    /// <summary>
    /// The untyped members of the <see langword="class" />.
    /// </summary>
    public Dictionary<string, string> UntypedMembers;

    /// <summary>
    /// Whether the <see langword="class" /> is <see langword="static" />
    /// </summary>
    public bool IsStatic;

    /// <summary>
    /// Whether this only contains <see langword="partial" /> <see langword="class" /> content.
    /// </summary>
    public bool Partial;

    /// <summary>
    /// Whether the class needs to generate headers.
    /// </summary>
    public bool RequiresAutoGeneratedHeaders;

    /// <summary>
    /// The using statements for the <see langword="class" />.
    /// </summary>
    public List<string> UsingStatements;

    /// <summary>
    /// The methods assigned to the <see langword="class" />.
    /// </summary>
    public ICodeBlock MethodContent;
}
#endregion

/// <summary>
/// Provides methods to generate code for Glue elements.
/// </summary>
public static class CodeWriter
{
    #region Fields

    /// <summary>
    /// Template code to define a screen.
    /// </summary>
    public const string ScreenTemplateCode =
@"using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;

using FlatRedBall;
using FlatRedBall.Input;
using FlatRedBall.Instructions;
using FlatRedBall.AI.Pathfinding;
using FlatRedBall.Graphics.Animation;
using FlatRedBall.Gui;
using FlatRedBall.Math;
using FlatRedBall.Math.Geometry;
using FlatRedBall.Localization;
using Microsoft.Xna.Framework;

// Additional usings


namespace FlatRedBallAddOns.Screens
{
    public partial class ScreenTemplate
    {

        void CustomInitialize()
        {


        }

        void CustomActivity(bool firstTimeCalled)
        {


        }

        void CustomDestroy()
        {


        }

        static void CustomLoadStaticContent(string contentManagerName)
        {


        }

    }
}
";

    /// <summary>
    /// Template code for custom entities.
    /// </summary>
    public const string EntityTemplateCode =
@"using System;
using System.Collections.Generic;
using System.Text;
using FlatRedBall;
using FlatRedBall.Input;
using FlatRedBall.Instructions;
using FlatRedBall.AI.Pathfinding;
using FlatRedBall.Graphics.Animation;
using FlatRedBall.Graphics.Particle;
using FlatRedBall.Math.Geometry;
using Microsoft.Xna.Framework;

namespace FlatRedBallAddOns.Entities
{
    public partial class GlueEntityTemplate
    {
        /// <summary>
        /// Initialization logic which is executed only one time for this Entity (unless the Entity is pooled).
        /// This method is called when the Entity is added to managers. Entities which are instantiated but not
        /// added to managers will not have this method called.
        /// </summary>
        private void CustomInitialize()
        {


        }

        private void CustomActivity()
        {


        }

        private void CustomDestroy()
        {


        }

        private static void CustomLoadStaticContent(string contentManagerName)
        {


        }
    }
}
";
    
    #endregion

    #region Properties

    /// <summary>
    /// List of code generators that are in use.
    /// </summary>
    public static List<ElementComponentCodeGenerator> CodeGenerators { get; set; }

    /// <summary>
    /// List of code generators for global content in the game.
    /// </summary>
    public static List<GlobalContentCodeGeneratorBase> GlobalContentCodeGenerators { get; }

    #endregion

    #region Methods

    /// <summary>
    /// Static constructor to initialize the <see cref="CodeGenerators"/> list.
    /// </summary>
    static CodeWriter()
    {
        CodeGenerators = new List<ElementComponentCodeGenerator>
        {
            new ErrorCheckingCodeGenerator(),
            new ScrollableListCodeGenerator(),
            new StateCodeGenerator(),
            new FactoryElementGeneratorEarly(),
            new FactoryElementCodeGenerator(),
            new ReferencedFileSaveCodeGenerator(),
            new NamedObjectSaveCodeGenerator(),
            new CustomVariableCodeGenerator(),
            new EventCodeGenerator(),
            new PooledCodeGenerator(),
            new IVisibleCodeGenerator(),
            new IWindowCodeGenerator(),
            new ITiledTileMetadataCodeGenerator(),
            new PauseCodeGenerator(),
            new LoadingScreenCodeGenerator()
        };

        GlobalContentCodeGenerators = new List<GlobalContentCodeGeneratorBase>();
    }

    /// <summary>
    /// Generates code for the specified <see cref="GlueElement"/>.
    /// </summary>
    /// <param name="element">Element to generate code for.</param>
    /// <returns><see cref="Task"/> completion</returns>
    /// <exception cref="ArgumentNullException"></exception>
    /// <exception cref="Exception">Thrown if <see cref="ReferencedFileSaveCodeGenerator.GlobalContentFilesDictionary"/> is <see langword="null" />.</exception>
    public static async Task GenerateCode(GlueElement element)
    {
        TaskManager.Self.WarnIfNotInTask();

        #region Prepare for generation

        if (element == null)
        {
            throw new ArgumentNullException(nameof(element));
        }

        // Since anything can modify an enumeration value we want to make sure that
        // it's proper before generating code for it:
        // If enumeration values don't work property let's just print some output and carry on
        try
        {
            element.FixEnumerationValues();
        }
        catch (Exception e)
        {
            PluginManager.ReceiveError($"Error fixing enumerations for {element}: {e}");
        }


        // Do this before doing anything else since 
        // these reusable entire file RFS's are used 
        // in other code.
        RefreshReusableEntireFileRfses(element);
        #endregion

        #region Event Generation

        EventCodeGenerator.GenerateEventGeneratedFile(element);

        if (element.Events.Count != 0)
        {
            var sharedCodeFullFileName =
                EventResponseSave.GetSharedCodeFullFileName(element, FileManager.GetDirectory(GlueState.Self.GlueProjectFileName.FullPath));

            EventCodeGenerator.CreateEmptyCodeIfNecessary(element,
                sharedCodeFullFileName, false);
        }
        
        EventCodeGenerator.AddStubsForCustomEvents(element);

        #endregion

        CreateGeneratedFileIfNecessary(element);

        foreach (PluginManager pluginManager in PluginManagerBase.GetInstances().Cast<PluginManager>())
        {
            CodeGeneratorPluginMethods.CallCodeGenerationStart(pluginManager, element);
        }

        if (!GlobalContentCodeGenerator.SuppressGlobalContentDictionaryRefresh)
        {
            ReferencedFileSaveCodeGenerator.RefreshGlobalContentDictionary();
        }

        if (ReferencedFileSaveCodeGenerator.GlobalContentFilesDictionary == null)
        {
            throw new Exception("Global content files dictionary should not be null");
        }
        
        var classNamespace = GetGlueElementNamespace(element);
        var rootBlock = new CodeDocument(0);

        GenerateDefines(rootBlock);

        UsingsCodeGenerator.GenerateUsingStatements(rootBlock, element);


        CodeBlockNamespace namespaceBlock = rootBlock.Namespace(classNamespace);
        ICodeBlock codeBlock = GenerateClassHeader(element, namespaceBlock);

        GenerateFieldsAndProperties(codeBlock, element);
        GenerateConstructors(codeBlock, element);
        GenerateInitialize(codeBlock, element);
        GenerateAddToManagers(codeBlock, element);
        GenerateActivity(codeBlock, element);

        if(GlueState.Self.CurrentGlueProject.FileVersion >= (int)GlueProjectSave.GluxVersions.ScreensHaveActivityEditMode)
        {
            GenerateActivityEditMode(codeBlock, element);
        }

        GenerateDestroy(codeBlock, element);
        GenerateMethods(codeBlock, element);

        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators)
        {
            codeGenerator.GenerateAdditionalClasses(namespaceBlock, element);
        }

        var generatedCodeFileName = element.Name + ".Generated.cs";
        var contentsToSave = rootBlock.ToString();

        SaveFileContents(contentsToSave, FileManager.RelativeDirectory + generatedCodeFileName, true);

        #region Extra stuff if it's an EntitySave

        if (element is EntitySave entitySave)
        {
            #region If this thing is created by other entities, then we should make it IPoolable

            if (entitySave.CreatedByOtherEntities)
            {
                var isAbstract = entitySave.AllNamedObjects.Any(item => item.SetByDerived);
                if(!isAbstract)
                {
                    FactoryElementCodeGenerator.GenerateAndAddFactoryToProjectClass(entitySave);
                }
            }

            #endregion

        }
        #endregion

        // This code will create and add above, but if the file already exists, the code above won't re-add it to the 
        // project. This is a last chance to add it if necessary:
        await GlueCommands.Self.ProjectCommands.TryAddCodeFileToProjectAsync(GetAbsoluteGeneratedCodeFileFor(element), saveOnAdd: true);
    }

    #region Predefines like #if ANDROID

    /// <summary>
    /// Generating define blocks to support different platforms, e.g. Android or iOS.
    /// </summary>
    /// <param name="rootBlock">Root block of the code.</param>
    public static void GenerateDefines(ICodeBlock rootBlock)
    {
        rootBlock.Line("#if ANDROID || IOS || DESKTOP_GL");
        rootBlock.Line("#define REQUIRES_PRIMARY_THREAD_LOADING");
        rootBlock.Line("#endif");

        GlueProjectSave project = GlueState.Self.CurrentGlueProject;
        if(project.FileVersion >= (int)GlueProjectSave.GluxVersions.SupportsEditMode)
        {
            rootBlock.Line("#define SUPPORTS_GLUEVIEW_2");
        }
        else
        {
            rootBlock.Line($"// The project is not new enough to support GlueView 2. It is on version {project.FileVersion}");
            rootBlock.Line("//#define SUPPORTS_GLUEVIEW_2");

        }
    }

    #endregion

    #region Namespace

    /// <summary>
    /// Retrieves the namespace for the specified <see cref="GlueElement"/>.
    /// </summary>
    /// <param name="element">Element to retrieve the namespace for</param>
    /// <returns>Retrieved namespace</returns>
    public static string GetGlueElementNamespace(GlueElement element)
    {
        var classNamespace = ProjectManager.ProjectNamespace;

        if (element is EntitySave)
        {
            var directory = FileManager.MakeRelative(FileManager.GetDirectory(element.Name));

            if (!directory.Equals($"Entities/", StringComparison.OrdinalIgnoreCase))
            {
                var relativeDirectory = FileManager.MakeRelative(directory);
                relativeDirectory = relativeDirectory[..^1];
                relativeDirectory = relativeDirectory.Replace('/', '.');

                classNamespace += "." + relativeDirectory;
            }
            else
            {
                classNamespace += ".Entities";
            }
        }
        else if (element is ScreenSave)
        {
            classNamespace += ".Screens";
        }

        return classNamespace;
    }

    #endregion

    #region Class Header

    /// <summary>
    /// Generates a class header for the specified <see cref="IElement"/> and writes this to <paramref name="namespaceBlock"/>.
    /// </summary>
    /// <param name="element">Element to generate the class header for</param>
    /// <param name="namespaceBlock">Code block to write to.</param>
    /// <returns>Code block for the class</returns>
    private static ICodeBlock GenerateClassHeader(GlueElement element, ICodeBlock namespaceBlock)
    {
        var inheritance = GetInheritance(element);

        if(!String.IsNullOrEmpty(inheritance))
        {
            inheritance = " : " + inheritance;
        }

        var isAbstract = element.AllNamedObjects.Any(item => item.SetByDerived);

        var optionalAbstractString = isAbstract ? "abstract " : String.Empty;

        ICodeBlock classCodeBlock = namespaceBlock.Class($"public {optionalAbstractString}partial", FileManager.RemovePath( element.Name), inheritance);

        return classCodeBlock;
    }

    /// <summary>
    /// Retrieves the inheritance stack for the specified <see cref="IElement"/>, as a comma separated string.
    /// </summary>
    /// <param name="element">Element to get the inheritance from.</param>
    /// <returns>Inheritances of the element, comma separated.</returns>
    private static string GetInheritance(GlueElement element)
    {
        string whatToInheritFrom;

        if (element is EntitySave entitySave)
        {
            List<string> inheritanceList = 
                InheritanceCodeWriter.Self.GetInheritanceList(entitySave, out EntitySave _);

            whatToInheritFrom = String.Join(", ", inheritanceList);
        }
        else // Screen
        {
            var inherits = !String.IsNullOrEmpty(element.BaseElement) && element.BaseElement != "<NONE>";
            whatToInheritFrom = inherits ? FileManager.RemovePath(element.BaseElement) : "FlatRedBall.Screens.Screen";

            List<string> inheritanceList = new();
            foreach (ElementComponentCodeGenerator generator in CodeGenerators)
            {
                generator.AddInheritedTypesToList(inheritanceList, element);
            }
            whatToInheritFrom += String.Join(", ", inheritanceList);
        }

        return whatToInheritFrom;
    }

    #endregion

    #region Fields/Properties

    /// <summary>
    /// Generates fields and properties for <paramref name="element"/> and writes this to <paramref name="codeBlock"/>.
    /// </summary>
    /// <param name="element">Element to write the fields and properties for</param>
    /// <param name="codeBlock">Code block to write the fields and properties to</param>
    /// <exception cref="Exception">If a code writer is in a <see langword="null"/> state,
    /// or if an error occurs while generating fields.</exception>
    internal static void GenerateFieldsAndProperties(ICodeBlock codeBlock, GlueElement element)
    {
        if(element is EntitySave entitySave)
        {
            EntityCodeWriter.GenerateFieldsAndProperties(entitySave, codeBlock);
        }

        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators)
        {
            if (codeGenerator == null)
            {
                throw new Exception("The CodeWriter contains a code generator in a null state. A plugin must have added this");
            }

            try
            {
                codeGenerator.GenerateFields(codeBlock, element);
            }
            catch (Exception e)
            {
                throw new Exception($"Error generating fields in generator {codeGenerator.GetType().Name}\n\n{e}");
            }
        }

        PerformancePluginCodeGenerator.GenerateFields(codeBlock, element);

        // No need to create LayerProvidedByContainer if this inherits from another object.
        if (element is EntitySave && !element.InheritsFromEntity())
        {
            // Add the layer that is going to get assigned in generated code
            codeBlock.Line("protected FlatRedBall.Graphics.Layer LayerProvidedByContainer = null;");
        }  
    }

    #endregion

    #region Constructor

    /// <summary>
    /// Generates constructor(s) for <paramref name="element"/> and writes them to <paramref name="codeBlock"/>.
    /// </summary>
    /// <param name="element">Element to write constructor(s) for.</param>
    /// <param name="codeBlock">Code block to write the constructor(s) to.</param>
    private static void GenerateConstructors(ICodeBlock codeBlock, GlueElement element)
    {
        ICodeBlock constructor;

        var elementName = FileManager.RemovePath(element.Name);

        if (element is EntitySave entitySave)
        {
            codeBlock.Constructor("public", elementName, "", "this(FlatRedBall.Screens.ScreenManager.CurrentScreen.ContentManagerName, true)");

            codeBlock.Constructor("public", elementName, "string contentManagerName", "this(contentManagerName, true)");

            var inheritsFromEntity = element.InheritsFromEntity();
            constructor = codeBlock.Constructor("public", elementName, "string contentManagerName, bool addToManagers",
                inheritsFromEntity
                    ? "base(contentManagerName, addToManagers)"
                    : "base()");

            constructor.Line(entitySave.UseGlobalContent
                ? "ContentManagerName = FlatRedBall.FlatRedBallServices.GlobalContentManager;"
                : "ContentManagerName = contentManagerName;");

            // See below on why we do this here
            CallElementComponentCodeGeneratorGenerateConstructor(element, constructor);

            // The base will handle this
            if (element.InheritsFromEntity() == false)
            {
                constructor.Line("InitializeEntity(addToManagers);");
            }
        }
        else // screen save
        {
            var contentManagerName = (element.UseGlobalContent) ? "\"Global\"" : $"\"{elementName}\"";
 
            // Feb 13, 2022,
            // This constructor enables the old FRB code to call in to this with no parameters without breaking reflection
            // No need to change it since screens are almost never explicitly constructed
            codeBlock.Constructor("public", elementName, "", $"this ({contentManagerName})");

            constructor = codeBlock.Constructor("public", elementName, "string contentManagerName", $"base (contentManagerName)");

            CallElementComponentCodeGeneratorGenerateConstructor(element, constructor);
        }

        return;

        static void CallElementComponentCodeGeneratorGenerateConstructor(GlueElement element, ICodeBlock constructor)
        {
            foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators)
            {
                try
                {
                    codeGenerator.GenerateConstructor(constructor, element);
                }
                catch (Exception e)
                {
                    GlueCommands.Self.PrintError(
                        $"Error calling GenerateConstructor on {codeGenerator.GetType()}:\n{e}");
                }
            }
        }
    }
    #endregion

    #region Load Static Content

    /// <summary>
    /// Generates static content to load for the file.
    /// </summary>
    /// <param name="codeBlock">Code block to write the content to</param>
    /// <param name="element">Element to write the content for</param>
    private static void GenerateLoadStaticContent(ICodeBlock codeBlock, GlueElement element)
    {
        var inheritsFromElement = element.InheritsFromElement();

        codeBlock = codeBlock.Function(StringHelper.SpaceStrings(
                                                    "public",
                                                    "static",
                                                    inheritsFromElement ? "new" : null,
                                                    "void"),
                                     "LoadStaticContent",
                                     "string contentManagerName");

        if (element is EntitySave)
        {
            // Currently only EntitySaves have access to LoadedContentManagers
            // The reason we have this here is that if two Entities reference
            // each other ( https://github.com/vchelaru/FlatRedBall/issues/1017 )
            // then an infinitely recursive call can happen.  We can use LoadedContentManagers
            // to prevent this. We do this here instead of in the ReferencedFileSave generated code
            // because we want to exit out immediately before anything else has a chance to run. The 
            // RFS code generator can't do this without some hacks.
            codeBlock.If("LoadedContentManagers.Contains(contentManagerName)")
                .Line("return;");
        }
        
        PerformancePluginCodeGenerator.GenerateStart(element, codeBlock, "LoadStaticContent");

        codeBlock.Line("bool oldShapeManagerSuppressAdd = FlatRedBall.Math.Geometry.ShapeManager.SuppressAddingOnVisibilityTrue;");
        codeBlock.Line("FlatRedBall.Math.Geometry.ShapeManager.SuppressAddingOnVisibilityTrue = true;");

        codeBlock.If("string.IsNullOrEmpty(contentManagerName)")
            .Line("throw new System.ArgumentException(\"contentManagerName cannot be empty or null\");")
            .End();

        #region Set the ContentManagerName ( do this BEFORE checking for IsStaticContentLoaded )

        if (element is EntitySave entitySave)
        {
            if (entitySave.UseGlobalContent)
            {
                codeBlock.Line("// Set to use global content");
                codeBlock.Line("contentManagerName = FlatRedBall.FlatRedBallServices.GlobalContentManager;");
            }
            codeBlock.Line("ContentManagerName = contentManagerName;");
        }

        #endregion


        if (inheritsFromElement)
        {
            codeBlock.Line("global::" + ProjectManager.ProjectNamespace + "." + element.BaseElement.Replace("\\", ".")  + ".LoadStaticContent(contentManagerName);");
        }

        codeBlock = CodeGenerators.OrderBy(item => (int)item.CodeLocation)
            .Aggregate(codeBlock, (current, codeGenerator) => codeGenerator.GenerateLoadStaticContent(current, element));

        #region Register the unload for EntitySaves

        // Vic says - do we want this for Screens too?
        // I don't think we do because Screens can just null- out stuff in their Destroy method.  There's only one of them around at a time.

        if (element is EntitySave { UseGlobalContent: false } save)
        {
            ICodeBlock ifBlock = codeBlock.If("registerUnload && ContentManagerName != FlatRedBall.FlatRedBallServices.GlobalContentManager");
            ReferencedFileSaveCodeGenerator.AppendAddUnloadMethod(ifBlock, save);
        }

        #endregion

        codeBlock.Line("CustomLoadStaticContent(contentManagerName);");
        codeBlock.Line("FlatRedBall.Math.Geometry.ShapeManager.SuppressAddingOnVisibilityTrue = oldShapeManagerSuppressAdd;");

        PerformancePluginCodeGenerator.GenerateEnd(element, codeBlock, "LoadStaticContent");
    }

    #endregion

    /// <summary>
    /// Save the file contents to the specified <paramref name="fileName"/>
    /// </summary>
    /// <param name="fileContents">Text contents of the file</param>
    /// <param name="fileName">File directory</param>
    /// <param name="tryAgain">Whether to retry on failure</param>
    /// <param name="standardizeNewlines"></param>
    /// <returns><see langword="true" /> on success.</returns>
    /// <exception cref="ArgumentNullException">If <paramref name="fileName"/> is <see langword="null" /></exception>
    public static bool SaveFileContents(string fileContents, string fileName, bool tryAgain, bool standardizeNewlines = true)
    {
        ArgumentNullException.ThrowIfNull(fileName, nameof(fileName));
        
        if(standardizeNewlines && !String.IsNullOrEmpty(fileContents))
        {
            // from: https://stackoverflow.com/questions/31053/regex-c-replace-n-with-r-n
            // for: https://github.com/vchelaru/FlatRedBall/issues/103
            fileContents = System.Text.RegularExpressions.Regex.Replace(fileContents, "(?<!\r)\n", "\r\n");
        }

        var isReadOnly = File.Exists(fileName) && new FileInfo(fileName).IsReadOnly;

        if (isReadOnly)
        {
            GlueGui.ShowMessageBox($"Could not save file\n\n{fileName}\n\nbecause it is marked read-only.");
        }
        else
        {
            if(fileName.Contains(".generated.", StringComparison.InvariantCultureIgnoreCase))
            {
                fileContents = $"#pragma warning disable\r\n{fileContents}";
            }

            if (!tryAgain)
            {
                GlueCommands.Self.FileCommands.SaveIfDiffers(fileName, fileContents, ignoreNextChange: true);
            }
            else
            {
                try
                {
                    GlueCommands.Self.TryMultipleTimes(() => GlueCommands.Self.FileCommands.SaveIfDiffers(fileName, fileContents, ignoreNextChange: true));
                }
                catch
                {
                    var errorMessage = "Could not generate the file " + fileName + "\n\n" +
                                       "Try manually re-generating this through Glue.  This is not a fatal error.";

                    GlueCommands.Self.PrintOutput(errorMessage);
                }
            }
        }
        return tryAgain;
    }

    /// <summary>
    /// Get the absolute file path for the generated code file for the specified <paramref name="element"/>.
    /// </summary>
    /// <param name="element">Element to save</param>
    /// <returns>Found <see cref="FilePath"/></returns>
    public static FilePath GetAbsoluteGeneratedCodeFileFor(GlueElement element)
    {
        var fileName = element.Name + ".Generated.cs";

        FilePath absoluteFileName = fileName;

        if (FileManager.IsRelative(fileName))
        {
            absoluteFileName = GlueState.Self.CurrentGlueProjectDirectory + fileName;
        }

        return absoluteFileName;
    }

    /// <summary>
    /// Generate a file if it doesn't exist for the specified <paramref name="element"/>.
    /// </summary>
    /// <param name="element">Element to generate the file for, it doesn't exist.</param>
    public static void CreateGeneratedFileIfNecessary(GlueElement element)
    {
        FilePath absoluteFilePath = GetAbsoluteGeneratedCodeFileFor(element);
        if (absoluteFilePath.Exists() == false)
        {
            CreateAndAddGeneratedFile(element);
        }
    }

    /// <summary>
    /// Generate a new file for the specified <paramref name="element"/>.
    /// </summary>
    /// <param name="element">Element to generate</param>
    public static void CreateAndAddGeneratedFile(GlueElement element)
    {
        // let's make a generated file
        var fileName = element.Name + ".Generated.cs";
        ProjectManager.CodeProjectHelper.CreateAndAddPartialGeneratedCodeFile(fileName, true);
        PluginManager.ReceiveOutput("Glue has created the generated file " + FileManager.RelativeDirectory + element.Name + ".cs");
    }

    /// <summary>
    /// Reusable entire file RFSes for the entire project.
    /// </summary>
    public static Dictionary<string, string> ReusableEntireFileRfses { get; } = new();

    /// <summary>
    /// Refresh the reusable entire file RFSes for the specified <paramref name="element"/>.
    /// </summary>
    /// <param name="element">Element to refresh the RFSes for.</param>
    private static void RefreshReusableEntireFileRfses(GlueElement element)
    {
        ReusableEntireFileRfses.Clear();

        // Fill the mReusableEntireFileRfses
        foreach (NamedObjectSave nos in 
                 element.NamedObjects.Where(nos => nos.IsEntireFile && nos.SourceFile != null && ReusableEntireFileRfses.ContainsKey(nos.SourceFile) == false))
        {
            ReusableEntireFileRfses.Add(nos.SourceFile, nos.FieldName);
        }
        IVisibleCodeGenerator.ReusableEntireFileRfses = ReusableEntireFileRfses;
        NamedObjectSaveCodeGenerator.ReusableEntireFileRfses = ReusableEntireFileRfses;
    }

    #region Initialize

    /// <summary>
    /// Generate the header for the Initialize() method of <paramref name="element"/>.
    /// </summary>
    /// <param name="element">Element to generate the method for</param>
    /// <param name="codeBlock">Code block to write the code to</param>
    internal static void GenerateInitialize(ICodeBlock codeBlock, GlueElement element)
    {
        TaskManager.Self.WarnIfNotInTask();

        string initializePre;
        string initializeMethodCall;
        if (element is ScreenSave)
        {
            initializePre = "public override void";
            initializeMethodCall = "Initialize";
        }
        else
        {
            initializeMethodCall = "InitializeEntity";
            initializePre = element.InheritsFromElement()
                ? "protected override void"
                : "protected virtual void";
        }

        codeBlock = codeBlock.Function(initializePre, initializeMethodCall, "bool addToManagers");

        // Start measuring performance before anything else
        PerformancePluginCodeGenerator.GenerateStartTimingInitialize(element, codeBlock);

        PerformancePluginCodeGenerator.SaveObject = element;
        PerformancePluginCodeGenerator.CodeBlock = codeBlock;

        PerformancePluginCodeGenerator.GenerateStart("CustomLoadStaticContent from Initialize");

        // Load static content before looping through the CodeGenerators
        // The reason for this is there is a ReferencedFileSaveCodeGenerator
        // which needs to work with static RFS's which are instantiated here
        codeBlock.Line("LoadStaticContent(ContentManagerName);");

        PerformancePluginCodeGenerator.GenerateEnd();
        PerformancePluginCodeGenerator.GenerateStart("General Initialize internals");

        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators)
        {
            try
            {
                codeGenerator.GenerateInitialize(codeBlock, element);
            }
            catch (Exception e)
            {
                GlueCommands.Self.PrintError($"Error calling GenerateInitialize on {codeGenerator.GetType()}:\n{e}");
            }
        }

        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators)
        {
            try
            {
                codeGenerator.GenerateInitializeLate(codeBlock, element);
            }
            catch(Exception e)
            {
                GlueCommands.Self.PrintError($"Error calling GenerateInitializeLate on {codeGenerator.GetType()}:\n{e}");
            }
        }

        NamedObjectSaveCodeGenerator.GenerateCollisionRelationships(codeBlock, element);

        if (element is ScreenSave screenSave)
        {
            codeBlock._();

            if (screenSave.IsRequiredAtStartup)
            {
                var startupScreen = GlueCommands.Self.GluxCommands.StartUpScreenName;

                var qualifiedName = ProjectManager.ProjectNamespace + "." + startupScreen.Replace("\\", ".");

                codeBlock.Line($"this.NextScreen = typeof({qualifiedName}).FullName;");
            }
        }

        codeBlock._();
        PerformancePluginCodeGenerator.GenerateEnd();

        #region PostInitializeCode

        PerformancePluginCodeGenerator.GenerateStart("Post Initialize");


        if (element.InheritsFromElement() == false)
        {
            codeBlock.Line("PostInitialize();");
        }
        PerformancePluginCodeGenerator.GenerateEnd();

        #endregion

        PerformancePluginCodeGenerator.GenerateStart("Base.Initialize");
        
        InheritanceCodeWriter.Self.WriteBaseInitialize(element, codeBlock);

        if(element is ScreenSave && GlueState.Self.CurrentGlueProject.FileVersion >= (int)GlueProjectSave.GluxVersions.ScreenIsINameable)
        {
            var name = element.GetStrippedName();
            codeBlock.Line($"this.Name = \"{name}\";");
        }

        // This needs to happen after calling WriteBaseInitialize so that the derived overwrites the base
        if (element is ScreenSave asScreenSave)
        {
            if (!String.IsNullOrEmpty(asScreenSave.NextScreen))
            {
                var nameToUse = ProjectManager.ProjectNamespace + "." + asScreenSave.NextScreen.Replace("\\", ".");

                codeBlock.Line($"this.NextScreen = typeof({nameToUse}).FullName;");
            }
        }
        PerformancePluginCodeGenerator.GenerateEnd();

        // I think we want to set this after calling base.Initialize so that the base
        // has a chance to set values on derived objects
        PerformancePluginCodeGenerator.GenerateStart("Reset Variables");
        // Now that variables are set, we can record reset variables
        NamedObjectSaveCodeGenerator.AssignResetVariables(codeBlock, element);
        PerformancePluginCodeGenerator.GenerateEnd();

        PerformancePluginCodeGenerator.GenerateStart("AddToManagers");


        #region If shouldCallAddToManagers, call AddToManagers
        var shouldCallAddToManagers = !element.InheritsFromElement();
        if (shouldCallAddToManagers)
        {
            ICodeBlock ifBlock = codeBlock
                .If("addToManagers");
            if (element is ScreenSave)
            {
                ifBlock.Line("AddToManagers();");
            }
            else
            {
                ifBlock.Line("AddToManagers(null);");
            }
        }

        #endregion
        PerformancePluginCodeGenerator.GenerateEnd();

        PerformancePluginCodeGenerator.GenerateEndTimingInitialize(element, codeBlock); 
    }

    #endregion

    /// <summary>
    /// Returns <see langword="true" /> if the specified <paramref name="element"/> is on its own layer.
    /// </summary>
    /// <param name="element">Element to check</param>
    /// <returns><see langword="true" /> if the specified <paramref name="element"/> is on its own layer.</returns>
    public static bool IsOnOwnLayer(GlueElement element)
    {
        if (element is EntitySave)
        {
            // The AddToManagers for EntitySaves takes a layer.  We should always
            // use this argument, but make sure all methods that take layered arguments
            // can work with null
            return true;

        }

        return ((ScreenSave)element).IsOnOwnLayer;
    }

    #region Add To Managers

    /// <summary>
    /// Generate the AddToManagers method for the specified <paramref name="element"/>.
    /// </summary>
    /// <param name="element">Element to write the method for.</param>
    /// <param name="codeBlock">Code block to write the method to.</param>
    internal static void GenerateAddToManagers(ICodeBlock codeBlock, GlueElement element)
    {  
        var isEntity = element is EntitySave;
        var isScreen = !isEntity;
 
        GenerateReAddToManagers(codeBlock, element);
 
        #region Generate the method header

        if (isScreen)
        {
            codeBlock = codeBlock
                .Function("public override void", "AddToManagers", "");
        }
        else if (element.InheritsFromElement()) // it's an EntitySave
        {
            codeBlock = codeBlock
                .Function("public override void", "AddToManagers", "FlatRedBall.Graphics.Layer layerToAddTo");
        }
        else // It's a base EntitySave
        {
            codeBlock = codeBlock
                .Function("public virtual void", "AddToManagers", "FlatRedBall.Graphics.Layer layerToAddTo");
        }
        #endregion

        if(isScreen)
        {
            // Screen.cs (in FlatRedBall Engine) assign mTimeScreenWasCreated. Unfortunately
            // that happens in the base class after all instances in the derived screen are created
            // and after their CustomInitialize is called. That CustomInitialize may use the TimeManager.CurrentScreenTime
            // which depends on the mTimeScreenWasCreated value being set. Therefore, we'll force set this here. It may get set
            // multiple times but that should be okay:
            codeBlock.Line("mAccumulatedPausedTime = TimeManager.CurrentTime;");
            codeBlock.Line("mTimeScreenWasCreated = FlatRedBall.TimeManager.CurrentTime;");
        }

        PerformancePluginCodeGenerator.SaveObject = element;
        PerformancePluginCodeGenerator.CodeBlock = codeBlock;

        PerformancePluginCodeGenerator.GenerateStart("Pooled PostInitialize");

        #region Call PostInitialize *again* if this is a pooled, base Entity

        // May 24, 2022,
        // This code is quite
        // old, but I believe this
        // is necessary because it re-initializes
        // the entity after being destroyed. "old" recycled
        // entities may have their internal objects shifted around,
        // so a post-init will reset them. 
        FactoryElementCodeGenerator.CallPostInitializeIfNecessary(element, codeBlock);


        #endregion

        PerformancePluginCodeGenerator.GenerateEnd();

        PerformancePluginCodeGenerator.GenerateStart("Layer for this code");


        #region Generate layer if a screen

        // Only Screens need to define a layer.  Otherwise, the layer is fed to the Entity
        if (IsOnOwnLayer(element) && isScreen)
        {
            codeBlock.Line("mLayer = SpriteManager.AddLayer();");
        }

        #endregion

        #region Assign the layer so that custom code can get to it

        if (isEntity)
        {
            codeBlock.Line("LayerProvidedByContainer = layerToAddTo;");
        }

        #endregion

        PerformancePluginCodeGenerator.GenerateEnd();

        GenerateAddThisEntityToManagers(codeBlock, element);

        const string addFilesToManagers = "Add Files to Managers";
        PerformancePluginCodeGenerator.GenerateStart(element, codeBlock, addFilesToManagers);
        
        // Add referenced files before adding objects because the objects
        // may be aliases for the files (if using Entire File) and may add them
        // to layers.
        ReferencedFileSaveCodeGenerator.GenerateAddToManagersStatic(
            codeBlock, element);

        PerformancePluginCodeGenerator.GenerateEnd(element, codeBlock, addFilesToManagers);
        PerformancePluginCodeGenerator.GenerateStart("Create layer instances");

        #region First generate all code for Layers before other stuff
        // We want the code for Layers to be generated before other stuff
        // since Layers may be used when generating the objects
        foreach (NamedObjectSave nos in element.NamedObjects)
        {
            if (nos.SourceType != SourceType.FlatRedBallType || nos.GetAssetTypeInfo()?.FriendlyName != "Layer")
            {
                continue;
            }

            NamedObjectSaveCodeGenerator.WriteAddToManagersForNamedObject(element, nos, codeBlock);

            foreach (CustomVariable customVariable in element.CustomVariables)
            {
                if (customVariable.SourceObject == nos.InstanceName)
                {
                    CustomVariableCodeGenerator.AppendAssignmentForCustomVariableInElement(codeBlock, customVariable, element as GlueElement);
                }
            }
        }
        #endregion

        PerformancePluginCodeGenerator.GenerateEnd();

        PerformancePluginCodeGenerator.GenerateStart("General AddToManagers code");

        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators
            .OrderBy(item => (int)item.CodeLocation)
            .Where(item => item.CodeLocation == CodeLocation.BeforeStandardGenerated))
        {
            codeGenerator.GenerateAddToManagers(codeBlock, element);
        }

        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators
            .OrderBy(item => (int)item.CodeLocation)
            .Where(item => item.CodeLocation == CodeLocation.StandardGenerated))
        {
            codeGenerator.GenerateAddToManagers(codeBlock, element);
        }
        PerformancePluginCodeGenerator.GenerateEnd();

        PerformancePluginCodeGenerator.GenerateStart("Add to managers base and bottom up");

        if ( element.InheritsFromElement())
        {
            codeBlock.Line(element is ScreenSave 
                ? "base.AddToManagers();" 
                : "base.AddToManagers(layerToAddTo);");
        }
        else
        {
            if (isScreen)
            {
                if (! element.InheritsFromElement())
                {
                    // Screen will always call base.AddToManagers so that
                    // Screen.cs gets a chance to set up its timing
                    codeBlock.Line("base.AddToManagers();");
                }
                codeBlock.Line("AddToManagersBottomUp();");

                if(!element.InheritsFromElement())
                {
                    if (GlueState.Self.CurrentGlueProject.FileVersion >= (int)GlueProjectSave.GluxVersions.SupportsEditMode)
                    {
                        codeBlock.Line("BeforeCustomInitialize?.Invoke();");
                    }
                }
            }
            else
            {
                codeBlock.Line("AddToManagersBottomUp(layerToAddTo);");
            }
        }
 
        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators
            .OrderBy(item => (int)item.CodeLocation)
            .Where(item => item.CodeLocation == CodeLocation.AfterStandardGenerated))
        {
            codeGenerator.GenerateAddToManagers(codeBlock, element);
        }
  
        PerformancePluginCodeGenerator.GenerateEnd(); 
        
        PerformancePluginCodeGenerator.GenerateStart("Custom Initialize");
        codeBlock.Line("CustomInitialize();");
        PerformancePluginCodeGenerator.GenerateEnd();
        
    }

    /// <summary>
    /// Generate the ReAddToManagers method for the specified <paramref name="element"/>.
    /// </summary>
    /// <param name="element">Element to write the method for.</param>
    /// <param name="codeBlock">Code block to write the method to.</param>
    private static void GenerateReAddToManagers(ICodeBlock codeBlock, GlueElement element)
    {
        var isEntity = element is EntitySave;

        var inheritsFromNonFrbType =
            !String.IsNullOrEmpty(element.BaseElement) && !element.InheritsFromFrbType();

        if (!isEntity)
        {
            return;
        } 

        if (inheritsFromNonFrbType)
        {
            codeBlock.Function("public override void", "ReAddToManagers", "FlatRedBall.Graphics.Layer layerToAddTo");
            codeBlock.Line("base.ReAddToManagers(layerToAddTo);");
        }
        else
        {
            codeBlock.Function("public virtual void", "ReAddToManagers", "FlatRedBall.Graphics.Layer layerToAddTo");
            codeBlock.Line("LayerProvidedByContainer = layerToAddTo;");
        }

        // add "this" to managers:
        GenerateAddThisEntityToManagers(codeBlock, element);

        foreach (NamedObjectSave nos in element.NamedObjects)
        {
            var setVariables = false;
            NamedObjectSaveCodeGenerator.WriteAddToManagersForNamedObject(element, nos, codeBlock, false, setVariables);
        }
    }

    /// <summary>
    /// Generate the AddToManagersBottomUp method for the specified <paramref name="element"/>.
    /// </summary>
    /// <param name="element">Element to write the method for.</param>
    /// <param name="codeBlock">Code block to write the method to.</param>
    private static void GenerateAddThisEntityToManagers(ICodeBlock codeBlock, GlueElement element)
    {
        if (element is not EntitySave entitySave)
        {
            return;
        }

        PerformancePluginCodeGenerator.GenerateStart("Add this to managers");

        if (element.InheritsFromFrbType())
        {
            AssetTypeInfo ati = AvailableAssetTypes.Self.GetAssetTypeFromRuntimeType(element.BaseObject, element);

            if (ati != null)
            {
                var addMethodIndex = 0;

                NamedObjectSave isContainerNos = element.AllNamedObjects.FirstOrDefault(item => item.IsContainer);

                if (isContainerNos is { IsZBuffered: true } &&
                    (String.Equals(isContainerNos.SourceClassType, "Sprite", StringComparison.OrdinalIgnoreCase) ||
                     String.Equals(isContainerNos.SourceClassType, "SpriteFrame", StringComparison.OrdinalIgnoreCase)))
                {
                    addMethodIndex = 1;
                }

                if(entitySave.IsManuallyUpdated)
                {
                    if (!String.IsNullOrEmpty(ati.AddManuallyUpdatedMethod))
                    {
                        var line = ati.AddManuallyUpdatedMethod
                            .Replace("{THIS}", "this")
                            .Replace("{LAYER}", "layerToAddTo") + ';';
                        codeBlock.Line(line);
                    }
                    else
                    {
                        // not adding this to managers 
                    }

                }
                else if(ati.AddToManagersFunc != null)
                {
                    codeBlock.Line(ati.AddToManagersFunc(element, null, null, "layerToAddTo"));
                }
                else if (ati.LayeredAddToManagersMethod.Count != 0)
                {
                    // just use the method as-is, because the template is already using "this"
                    codeBlock.Line(ati.LayeredAddToManagersMethod[addMethodIndex].Replace("mLayer", "layerToAddTo") + ";");
                }
                else if (ati.AddToManagersMethod.Count != 0)
                {
                    codeBlock.Line(ati.AddToManagersMethod[addMethodIndex] + ";");
                }
            }
        }
        else if (!element.InheritsFromElement())
        {
            codeBlock.Line(entitySave.IsManuallyUpdated
                ? "// This entity skips adding itself to FRB Managers because it has its IsManuallyUpdated property set to true"
                : "FlatRedBall.SpriteManager.AddPositionedObject(this);");
        }

        IWindowCodeGenerator.TryGenerateAddToManagers(codeBlock, element);
        PerformancePluginCodeGenerator.GenerateEnd();
    }

    #endregion

    #region Activity

    /// <summary>
    /// Generate activity for the specified <paramref name="element"/>.
    /// </summary>
    /// <param name="element">Element to write the method for.</param>
    /// <param name="codeBlock">Code block to write the method to.</param>
    internal static void GenerateActivity(ICodeBlock codeBlock, GlueElement element)
    {

        var activityPre = "public virtual void";
        var activityParameters = "";

        if (element is ScreenSave)
        {
            activityPre = "public override void";
            activityParameters = "bool firstTimeCalled";
        }
        else if (element.InheritsFromElement())
        {
            activityPre = "public override void";
        }
        codeBlock = codeBlock.Function(activityPre, "Activity", activityParameters);

        #region Plugin code generation before standard generation

        List<PluginManagerBase> pluginManagers = PluginManagerBase.GetInstances();
        ICodeBlock currentBlock = codeBlock;

        foreach (PluginManager pluginManager in pluginManagers.Cast<PluginManager>())
        {
            CodeGeneratorPluginMethods.GenerateActivityPluginCode(CodeLocation.BeforeStandardGenerated, pluginManager, codeBlock, element);
        }
        #endregion

        if (element is ScreenSave screenSave)
        { 
            currentBlock = currentBlock
                .If("!IsPaused");

            GenerateGeneralActivity(currentBlock, element);

            currentBlock = currentBlock
                .End();
    
            currentBlock = currentBlock
                .Else();

            GeneratePauseIgnoringActivity(currentBlock, screenSave);

            currentBlock = currentBlock
                .End();

            currentBlock.Line("base.Activity(firstTimeCalled);");
            currentBlock
                .If("!IsActivityFinished")
                    .Line("CustomActivity(firstTimeCalled);");

        }
        else
        {
            EntityCodeWriter.GenerateActivity(element as EntitySave, codeBlock);

            GenerateGeneralActivity(currentBlock, element);

            currentBlock.Line("CustomActivity();");

        }
        
        GenerateAfterActivity(codeBlock, element);
    }

    /// <summary>
    /// Generate activity edit mode for the specified <paramref name="element"/>.
    /// </summary>
    /// <param name="element">Element to write the method for.</param>
    /// <param name="codeBlock">Code block to write the method to.</param>
    private static void GenerateActivityEditMode(ICodeBlock codeBlock, GlueElement element)
    {

        var activityPre = "public virtual void";
 
        var inherits = element is ScreenSave || element.InheritsFromElement();

        if (inherits)
        {
            activityPre = "public override void";
        }
        

        ICodeBlock currentBlock = codeBlock.Function(activityPre, "ActivityEditMode", "");

        if(element is ScreenSave)
        {
            currentBlock = currentBlock.If("FlatRedBall.Screens.ScreenManager.IsInEditMode");

        }

        if(GlueState.Self.CurrentGlueProject.FileVersion >= (int)GlueProjectSave.GluxVersions.IEntityInFrb)
        {
            if(element is ScreenSave && !element.InheritsFromElement())
            {
                // The internal call could add or remove things from the FRB engine, so we shouldn't foreach here. Reverse loop it instead:
                //var foreachBlock = currentBlock.ForEach($"var item in FlatRedBall.SpriteManager.ManagedPositionedObjects");
                ICodeBlock forBlock = currentBlock.For("int i = FlatRedBall.SpriteManager.ManagedPositionedObjects.Count - 1; i > -1; i--");
                forBlock.Line("var item = FlatRedBall.SpriteManager.ManagedPositionedObjects[i];");
                ICodeBlock foreachIfBlock = forBlock.If("item is FlatRedBall.Entities.IEntity entity");
                foreachIfBlock.Line("entity.ActivityEditMode();");
            }
        }
        else
        {
            // Old version (before file version 10 in Dec 24 2021) required code gen to call custom activity.
            foreach(NamedObjectSave nos in element.NamedObjects)
            {
                if(!nos.DefinedByBase && !nos.IsDisabled)
                {
                    if(nos.SourceType == SourceType.Entity)
                    {
                        currentBlock.Line($"{nos.InstanceName}.ActivityEditMode();");
                    }
                    else if(nos.IsList && ObjectFinder.Self.GetEntitySave(nos.SourceClassGenericType) != null)
                    {
                        ICodeBlock foreachBlock = currentBlock.ForEach($"var item in {nos.InstanceName}");
                        foreachBlock.Line($"item.ActivityEditMode();");
                    }
                }
            }
        }

        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators)
        {
            codeGenerator.GenerateActivityEditMode(currentBlock, element);
        }

        currentBlock.Line("CustomActivityEditMode();");
 
        if(inherits)
        {
            currentBlock.Line("base.ActivityEditMode();");
        }
    }

    /// <summary>
    /// Generate the AfterActivity method for the specified <paramref name="element"/>.
    /// </summary>
    /// <param name="element">Element to write the method for.</param>
    /// <param name="codeBlock">Code block to write the method to.</param>
    internal static void GenerateGeneralActivity(ICodeBlock codeBlock, GlueElement element)
    {
        var isEntity = element is EntitySave;
        var entitySave = element as EntitySave;

        // This code might seem a little weird.  The reason we do this
        // is that when an Entity is paused, it has a method that is
        // called.  However, when it is unpaused, there's just an instruction
        // that is executed - there is no event.  But if a Screen is paused, then
        // objects within that Screen don't get unpaused....so we're going to bet on
        // the Activity function only being called in unpaused Screens.  If this causes
        // problems we may have to make something a little more standard like an Unpause
        // method.
        if (isEntity &&
            (entitySave.ImplementsIClickable || entitySave.ImplementsIWindow)
            && !entitySave.GetInheritsFromIWindowOrIClickable()
            )
        {
            codeBlock.Line("mIsPaused = false;");
        }

        #region Call base.Activity if it has a derived object

        // We only need to do this for EntitySaves.  Screens inherit from the
        // Screen class, so they ALWAYS call base.Activity.  It's in the generated
        // Screen template.  
        if ( element.InheritsFromEntity())
        {
            codeBlock.Line("base.Activity();");
        }

        #endregion

        codeBlock._();

        // Eventually do we want to move this in the generate activity for custom variable code gen.
        CustomVariableCodeGenerator.WriteVelocityForCustomVariables(element.CustomVariables, codeBlock);
        
        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators)
        {
            codeGenerator.GenerateActivity(codeBlock, element);
        }
    }

    #endregion

    /// <summary>
    /// Generate the Destroy() method of the specified <paramref name="element"/>.
    /// </summary>
    /// <param name="element">Element to write the method for.</param>
    /// <param name="codeBlock">Code block to write the method to.</param>
    internal static void GenerateDestroy(ICodeBlock codeBlock, GlueElement element)
    {

        var destroyPre = "public virtual void";

        var destroyInherits = element is ScreenSave || element.InheritsFromElement();

        if (destroyInherits)
        {
            destroyPre = "public override void";
        }

        codeBlock = codeBlock.Function(destroyPre, "Destroy", "");
        ICodeBlock currentBlock = codeBlock;
        
        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators
            // eventually split these up:
            .Where(item => item.CodeLocation == CodeLocation.BeforeStandardGenerated))
        {
            codeGenerator.GenerateDestroy(currentBlock, element);
        }


        #region Call base.Destroy if it has a derived object

        if (element.InheritsFromEntity() || element is ScreenSave)
        {
            currentBlock.Line("base.Destroy();");
        }

        #endregion


        #region If Entity, remove from managers (SpriteManager, GuiManager)

        if (element is EntitySave entitySave)
        {
            if (entitySave.InheritsFromFrbType())
            {
                AssetTypeInfo ati = AvailableAssetTypes.Self.GetAssetTypeFromRuntimeType(element.BaseObject, entitySave);

                if (ati != null)
                {
                    if(ati.DestroyFunc != null)
                    {
                        currentBlock.Line(ati.DestroyFunc(entitySave, null, null));
                    }
                    else
                    {
                        currentBlock.Line(ati.DestroyMethod + ";");
                    }
                }
            }
            else if (!entitySave.InheritsFromElement())
            {
                currentBlock.Line("FlatRedBall.SpriteManager.RemovePositionedObject(this);");
            }

            if (entitySave.ImplementsIWindow && !entitySave.GetInheritsFromIWindow())
            {
                currentBlock.Line("FlatRedBall.Gui.GuiManager.RemoveWindow(this);");
            }

        }

        #endregion

        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators
            // eventually split these up:
            .Where(item => item.CodeLocation is CodeLocation.AfterStandardGenerated or CodeLocation.StandardGenerated))
        {
            codeGenerator.GenerateDestroy(currentBlock, element);
        }

        // Sept 9, 2022
        // Not sure if this should be at the beginning or end, but adding this
        // at the end so it doesn't interrupt any other unload code:
        GenerateUnloadContentManager(currentBlock, element);

        codeBlock.Line("CustomDestroy();");
    }

    /// <summary>
    /// Generate UnloadContentManager() for <paramref name="element"/>
    /// </summary>
    /// <param name="element">Element to write the method for.</param>
    /// <param name="codeBlock">Code block to write the method to.</param>
    private static void GenerateUnloadContentManager(ICodeBlock codeBlock, GlueElement element)
    {
        var shouldUnload = 
            element is ScreenSave { UseGlobalContent: false } screenSave &&
            screenSave.ReferencedFiles.Any(item => item.LoadedOnlyWhenReferenced);

        // This code could be in a screen that is the base
        // for a derived screen (such as GameScreen for Level1)
        // In that case, Level1 would use its own content manager,
        // but when the LoadedOnlyWhenReferenced property is accessed,
        // the base content manager would get used. Screens automatically
        // clean up their content managers at the engine level, but only the
        // content manager specified by the most derived.

        if (shouldUnload)
        {
            codeBlock.Line($"FlatRedBall.FlatRedBallServices.Unload(\"{element.ClassName}\");");
        }
    }

/// <summary>
/// Generate a class based on the specified properties.
/// </summary>
/// <param name="classProperties">Properties</param>
/// <returns>Generated code block.</returns>
    public static ICodeBlock CreateClass(ClassProperties classProperties)
        => CreateClass(classProperties.NamespaceName, classProperties.ClassName, classProperties.Partial, classProperties.Members,
        classProperties.IsStatic, classProperties.UsingStatements, classProperties.UntypedMembers,
        classProperties.MethodContent);

    /// <summary>
    /// Generate a class based on the specified properties.
    /// </summary> 
    /// <param name="namespaceName">Namespace the class belongs to</param>
    /// <param name="className">Name of the class</param>
    /// <param name="members">Member methods of the class</param>
    /// <returns>Generated code block.</returns>
    public static ICodeBlock CreateClass(string namespaceName, string className, List<TypedMemberBase> members)
        => CreateClass(namespaceName, className, false, members, false,
        new List<string>(), new Dictionary<string, string>(), null);

    /// <summary>
    /// Generate a class based on the specified properties.
    /// </summary>
    /// <param name="namespaceName">Namespace the class belongs to</param>
    /// <param name="className">Name of the class</param>
    /// <param name="isPartial">Whether this is a partial class</param>
    /// <param name="members">Member methods of the class</param>
    /// <param name="isStatic">Whether this is a static class</param>
    /// <param name="usingStatements">Using statements at the top of the file.</param>
    /// <param name="untypedMembers">Untyped members of the class</param>
    /// <param name="methodContent">Content of the methods of the class</param>
    /// <returns>Generated code block.</returns>
    public static ICodeBlock CreateClass(string namespaceName, string className, bool isPartial, List<TypedMemberBase> members,
        bool isStatic, List<string> usingStatements, Dictionary<string, string> untypedMembers, ICodeBlock methodContent)
    {
        var codeBlock = new CodeDocument();

        #region Append Using Statements
        foreach(var usingStatement in usingStatements.Distinct())
        {
            codeBlock.Line("using " + usingStatement + ";");
        }
        #endregion

        #region Append Namespace

        codeBlock._();

        ICodeBlock currentBlock = codeBlock;

        currentBlock = currentBlock.Namespace(namespaceName);

        #endregion

        #region Append class header

        currentBlock = currentBlock.Class(pName: className, Public: true, Static: isStatic, Partial: isPartial);

        #endregion

        foreach (TypedMemberBase member in members)
        {
            var isPublic = member.Modifier == Modifier.Public;
            var isPrivate = member.Modifier == Modifier.Private;
            var isInternal = member.Modifier == Modifier.Internal;

            var memberType = member.MemberType.ToString();

            memberType = PrepareTypeToBeWritten(member, memberType);

            // We used to remove whitespace here,
            // but the member name may contain an assignment.
            // In that case we want spaces preserved.  Whatever
            // calls this method is in charge of removing whitespace.
            var memberName = member.MemberName;

            currentBlock.Line(StringHelper.Modifiers(
                Public: isPublic, 
                Private: isPrivate,
                Internal: isInternal,
                Static: isStatic, 
                Type: memberType, 
                Name: memberName) + ";");
        }

        foreach (var (memberName, type) in untypedMembers)
        {
            var isPublic = !memberName.StartsWith("m");
            currentBlock.Line(StringHelper.Modifiers(Public: isPublic, Static: isStatic, Type: type, Name: memberName) + ";");
        }
 
        if (methodContent == null)
        {
            currentBlock.Tag("Methods");
        }
        else
        {
            currentBlock.InsertBlock(methodContent);
        }

        currentBlock._()._();

        currentBlock.Replace(" System.Single ", " float ");
        currentBlock.Replace(" System.Boolean ", " bool ");
        currentBlock.Replace(" System.Int32 ", " int ");
        currentBlock.Replace(" System.String ", " string ");

        if(members.Any(item => item.MemberName == "Name" && item.MemberType == typeof(string)))
        {
            currentBlock.Line("public override string ToString() => Name;");
        }

        return codeBlock;
    }

    /// <summary>
    /// Prepare Type for writing
    /// </summary>
    /// <param name="member">Member to prepare</param>
    /// <param name="memberType">Type of the member.</param>
    /// <returns>Altered <paramref name="memberType"/></returns>
    private static string PrepareTypeToBeWritten(TypedMemberBase member, string memberType)
    {
        if (memberType.Contains("`1"))
        {
            // This is generic
            var name = memberType[..memberType.IndexOf('`')];

            // We want to use FullName rather than Name, so we don't rely on usings in generated code
            //string genericContents = PrepareTypeToBeWritten(null, member.MemberType.GetGenericArguments()[0].Name);
            var genericContents = PrepareTypeToBeWritten(null, member.MemberType.GetGenericArguments()[0].FullName);

            memberType = $"{name}<{genericContents}>";
        }
        else if (memberType.Contains("<"))
        {
            var name = memberType[..memberType.IndexOf('<')];

            // See above
            //string genericContents = PrepareTypeToBeWritten(null, member.MemberType.GetGenericArguments()[0].Name);
            var genericContents = PrepareTypeToBeWritten(null, member.MemberType.GetGenericArguments()[0].FullName);

            memberType = $"{name}<{genericContents}>";
        }
        else
        {
            memberType = TypeManager.GetCommonTypeName(memberType);
        }

        // Fully qualify FRB names to prevent clashes with 
        if(memberType.Contains("FlatRedBall."))
        {
            memberType = "global::" + memberType;
        }


        return memberType;
    }


/// <summary>
/// Set the base class of the generated file.
/// </summary>
/// <param name="fileName">Location of the file to be generated</param>
/// <param name="baseClass">Name of the base class</param>
    public static void SetBaseClass(string fileName, string baseClass)
    {
        SetBaseClass(fileName, baseClass, out var fileContents);

        FileManager.SaveText(fileContents, fileName + ".Generated.cs");
    }

    /// <summary>
    /// Set the base class of the generated file.
    /// </summary>
    /// <param name="fileName">Location of the file to be generated</param>
    /// <param name="baseClass">Name of the base class</param>
    /// <param name="fileContents">File contents for the generated class</param>
    public static void SetBaseClass(string fileName, string baseClass, out string fileContents) => SetBaseClass(fileName, baseClass, true, out fileContents);

    /// <summary>
    /// Set the base class of the generated file.
    /// </summary>
    /// <param name="fileName">Location of the file to be generated</param>
    /// <param name="baseClass">Name of the base class</param>
    /// <param name="overwrite">Whether to overwrite existing content</param>
    /// <param name="fileContents">File contents for the generated class</param>
    public static void SetBaseClass(string fileName, string baseClass, bool overwrite, out string fileContents)
    {
        fileContents = FileManager.FromFileText(fileName + ".Generated.cs");

        SetBaseClass(ref fileContents, baseClass, overwrite);

    }

    /// <summary>
    /// Set the base class of the generated file.
    /// </summary> 
    /// <param name="baseClass">Name of the base class</param>
    /// <param name="overwrite">Whether to overwrite existing content</param>
    /// <param name="fileContents">File contents for the generated class</param>
    public static void SetBaseClass(ref string fileContents, string baseClass, bool overwrite)
    {
        var wordAfter = StringFunctions.GetWordAfter(" : ", fileContents);

        if (overwrite)
        {
            fileContents = fileContents.Replace(" : " + wordAfter, " : " + baseClass);
        }
        else
        {
            var contents = " : " + wordAfter;
            var index = fileContents.IndexOf(contents, StringComparison.Ordinal) + contents.Length;
            fileContents = fileContents.Insert(index, ", " + baseClass);
        }

    }

    /// <summary>
    /// Initializes the static data for the game.
    /// </summary>
    /// <param name="relativeGameFileName">Path to the file where the static data is located.</param>
    public static void InitializeStaticData(string relativeGameFileName)
    {
        if (String.IsNullOrEmpty(relativeGameFileName))
        {
            return;
        }
        var gameFilePath = new FilePath(GlueState.Self.CurrentMainProject.Directory + relativeGameFileName);

        var contents = FileManager.FromFileText(gameFilePath.FullPath);
        var contentsBeforeChange = contents;
        var gluxVersion = GlueState.Self.CurrentGlueProject.FileVersion;
        if(gluxVersion < (int)GlueProjectSave.GluxVersions.HasGame1GenerateEarly)
        {
            AddGlobalContentInitializeInCustomCode(ref contents);
        }

        if(contents != contentsBeforeChange)
        {
            if (new FileInfo(gameFilePath.FullPath).IsReadOnly)
            {
                GlueGui.ShowMessageBox("The file\n\n" + gameFilePath + "\n\nis read-only, so Glue can't generate code");
            }
            else
            {
                FileWatchManager.IgnoreNextChangeOnFile(gameFilePath.Standardized);
                try
                {
                    GlueCommands.Self.TryMultipleTimes(() => FileManager.SaveText(contents, gameFilePath.FullPath));
                }
                catch 
                {
                    // If we failed, save a backup
                    FileManager.SaveText(contents, gameFilePath.FullPath + ".Backup");
                    throw;
                }
            }
        }
    }

    /// <summary>
    /// Add GlobalContent.Initialize(); to custom code.
    /// </summary>
    /// <param name="contents">Existing contents (in string format)</param>
    /// <exception cref="CodeParseException">Thrown if the method cannot be placed anywhere.</exception>
    private static void AddGlobalContentInitializeInCustomCode(ref string contents)
    {
        var lineToReplaceWith = "            " + "GlobalContent.Initialize();";

        if (contents.Contains("GlobalContent.Initialize"))
        {
            StringFunctions.ReplaceLine(ref contents, "GlobalContent.Initialize", lineToReplaceWith);
        }
        else
        {
            // We gotta find where to put the start call.  This should be after 
            // FlatRedBallServices.InitializeFlatRedBall

            var index = CodeParser.GetIndexAfterFlatRedBallInitialize(contents);

            if (index == -1)
            {
                throw new CodeParseException("Could not find FlatRedBall.Initialize in the Game file.  Did you delete this?  " +
                    "Glue requires this call to be in the Game class. You must manually add this call and reload Glue.");
            }
            contents = contents.Insert(index, lineToReplaceWith + Environment.NewLine);
        }

    }

    /// <summary>
    /// Replaces the namespace with a new name.
    /// </summary>
    /// <param name="fileContents">Existing file contents</param>
    /// <param name="newNamespace">New namespace name.</param>
    /// <returns>Altered <paramref name="fileContents"/></returns>
    internal static string ReplaceNamespace(string fileContents, string newNamespace)
        => ReplaceNamespace(fileContents, newNamespace, out var _);

    /// <summary>
    /// Replaces the namespace with a new name.
    /// </summary>
    /// <param name="fileContents">Existing file contents</param>
    /// <param name="newNamespace">New namespace name.</param>
    /// <param name="oldNamespace">Old namespace name.</param>
    /// <returns>Altered <paramref name="fileContents"/></returns>
    internal static string ReplaceNamespace(string fileContents, string newNamespace, out string oldNamespace)
    {
        var indexOfNamespaceKeyword = fileContents.IndexOf("namespace ", StringComparison.Ordinal);
        oldNamespace = "";
        if(indexOfNamespaceKeyword != -1)
        { 
            var indexOfNamespaceStart = indexOfNamespaceKeyword + "namespace ".Length;

            var indexOfSlashR = fileContents.IndexOf("\r", indexOfNamespaceStart, StringComparison.Ordinal);
            var indexOfSlashN = fileContents.IndexOf("\n", indexOfNamespaceStart, StringComparison.Ordinal);

            int indexOfEndOfNamespace;

            if (indexOfSlashR == -1)
            {
                indexOfEndOfNamespace = indexOfSlashN;
            }
            else if(indexOfSlashN == -1)
            {
                indexOfEndOfNamespace = indexOfSlashR;
            }
            else
            {
                indexOfEndOfNamespace = System.Math.Min(indexOfSlashR, indexOfSlashN);
            }

            oldNamespace = fileContents.Substring(indexOfNamespaceStart, indexOfEndOfNamespace - indexOfNamespaceStart);


            fileContents = fileContents.Remove(indexOfNamespaceStart, indexOfEndOfNamespace - indexOfNamespaceStart);

            fileContents = fileContents.Insert(indexOfNamespaceStart, newNamespace);

        }
        return fileContents;
    }

    /// <summary>
    /// Set the classname and namespace for the specified <paramref name="elementName"/>.
    /// </summary>
    /// <param name="projectNamespace">Namespace of the project</param>
    /// <param name="elementName">Name of the element</param>
    /// <param name="templateCode">Template code</param>
    public static void SetClassNameAndNamespace(string projectNamespace, string elementName, StringBuilder templateCode)
        => SetClassNameAndNamespace(projectNamespace, elementName, templateCode, false, "\"Global\"", null);

    /// <summary>
    /// Set the classname and namespace for the specified <paramref name="elementName"/>.
    /// </summary>
    /// <param name="classNamespace">Namespace of the class</param>
    /// <param name="elementName">Name of the element</param>
    /// <param name="templateCode">Template code</param>
    public static void SetClassNameAndNamespace(string classNamespace, string elementName, StringBuilder templateCode, bool useGlobalContent, string replacementContentManagerName, string inheritance)
    {
        var namespaceToReplace = StringFunctions.GetWordAfter("namespace ", templateCode);
        var isScreen = namespaceToReplace.Contains("Screen");
            
        var classNameToReplace = StringFunctions.GetWordAfter("public partial class ", templateCode);
        if (isScreen)
        {
            templateCode.Replace("namespace " + namespaceToReplace,
                "namespace " + classNamespace);
            
            if (useGlobalContent)
            {
                // replace the content manager name with the global content manager
                templateCode.Replace("\"" + classNameToReplace + "\"", replacementContentManagerName);

            }
        }
        else
        { 
            // This is a full namespace.  Okay, let's just use that if '.Entities' is present in the class namespace,
            // we reflect this in the namespace.
            var whatToReplaceWith =
                classNamespace.Contains(".Entities") && classNamespace.IndexOf('.') ==
                classNamespace.IndexOf(".Entities", StringComparison.Ordinal)
                    ? "namespace " + classNamespace
                    : "namespace " + classNamespace + ".Entities";

            templateCode.Replace("namespace " + namespaceToReplace,
                whatToReplaceWith);
        }

        if (!String.IsNullOrEmpty(inheritance))
        {
            templateCode.Replace(classNameToReplace,
             elementName);

            var indexOfClass = templateCode.IndexOf("class " + elementName);

            if (indexOfClass != -1)
            {
                var length = ("class " + elementName).Length;
                templateCode.Insert(indexOfClass + length, " : " + inheritance);
            }

        }
        else
        {
            templateCode.Replace(classNameToReplace,
                elementName);
        }
    }

    internal static void RefreshStartupScreenCode()
    {
        // If there is a required screen, then use that
        ScreenSave requiredScreen = null;

        for (var i = 0; i < ProjectManager.GlueProjectSave.Screens.Count; i++)
        {
            ScreenSave screenSave = ProjectManager.GlueProjectSave.Screens[i];

            if (screenSave.IsRequiredAtStartup)
            {
                requiredScreen = screenSave;
                break;
            }
        }

        var screenName = requiredScreen?.Name ?? 
            GlueCommands.Self.GluxCommands.StartUpScreenName;

        SetStartUpScreen(
            ProjectManager.GameClassFileName,
            screenName);
    }

    private static void SetStartUpScreen(string gameFileName, string startUpScreen)
    {
        var success = true;

        string contents = null;
        try
        {
            contents = FileManager.FromFileText(FileManager.RelativeDirectory + gameFileName);
        }
        catch(Exception e)
        {

            PluginManager.ReceiveError(e.ToString());
            success = false;
        }

        if (success)
        {

            #region Get the lineThatStartsEverything

            // isEmpty needs to get set
            // *before* prepending the ProjectNamespace
            var isEmpty = String.IsNullOrEmpty(startUpScreen);

            if(!isEmpty)
            {
                startUpScreen = ProjectManager.ProjectNamespace + "." + startUpScreen.Replace("\\", ".");
            }
            var lineThatStartsEverything =
                $"            FlatRedBall.Screens.ScreenManager.Start(typeof({startUpScreen}));";

            if (isEmpty)
            {
                lineThatStartsEverything = "            //FlatRedBall.Screens.ScreenManager.Start(typeof(YourScreenClass));";
            }

            #endregion

            if(contents.Contains("Type startScreenType = "))
            {
                var line = isEmpty ?
                    $"            Type startScreenType = null;" :
                    $"            Type startScreenType = typeof({startUpScreen});";
                // new projects (as of October 25 2019) use this multi-line approach
                StringFunctions.ReplaceLine(ref contents, "Type startScreenType = ", line);

            }
            else if (contents.Contains("ScreenManager.Start"))
            {
                StringFunctions.ReplaceLine(ref contents, "ScreenManager.Start", lineThatStartsEverything);
            }
            else
            {
                // We gotta find where to put the start call.  This should be after 
                // FlatRedBallServices.InitializeFlatRedBall

                var index = CodeParser.GetIndexAfterFlatRedBallInitialize(contents);
                contents = contents.Insert(index, lineThatStartsEverything + Environment.NewLine);
            }

            try
            {
                SaveFileContents(contents, FileManager.RelativeDirectory + gameFileName, true);
            }
            catch (Exception e)
            {
                PluginManager.ReceiveError(e.ToString());
            }
        }
    }

    private static bool IsCustomVariableAssignedInAddToManagers(CustomVariable customVariable, IElement saveObject)
    {
        if (!String.IsNullOrEmpty(customVariable.SourceObject))
        {
            NamedObjectSave nos = saveObject.GetNamedObjectRecursively(customVariable.SourceObject);

            if (nos != null)
            {
                AssetTypeInfo ati = nos.GetAssetTypeInfo();

                if (ati is { IsInstantiatedInAddToManagers: true })
                {
                    return true;
                }
            }
        }
        return false;
    }

    public static void GeneratePostInitialize(ICodeBlock codeBlock, GlueElement saveObject)
    {
        // PostInitialize is a method which can be called multiple times if an entity is pooled. Therefore, any "add" calls here must
        // be protected with if-checks.

        ICodeBlock currentBlock = codeBlock;
        var inheritsFromElement = saveObject.InheritsFromElement();
        currentBlock = currentBlock
            .Function("PostInitialize", "", Public: true, Override: inheritsFromElement, Virtual: !inheritsFromElement, Type: "void");

        // PostInitialize may happen async - but setting Visible = true on a shape
        // adds it to the ShapeManager.  This is bad because:
        // 1.  It's not thread safe
        // 2.  Another Screen may be visible
        // 3.  The ScreenManager checks for the presence of objects in the managers after a Screen is destroyed.  An addition would (and has) cause a crash here
        currentBlock.Line("bool oldShapeManagerSuppressAdd = FlatRedBall.Math.Geometry.ShapeManager.SuppressAddingOnVisibilityTrue;");
        currentBlock.Line("FlatRedBall.Math.Geometry.ShapeManager.SuppressAddingOnVisibilityTrue = true;");


        // Events need to come first here
        // in case other generators set properties
        // that raise events.
        EventCodeGenerator.GeneratePostInitialize(currentBlock, saveObject);

        if (inheritsFromElement)
        {
            currentBlock.Line("base.PostInitialize();");
        }


        // Do attachments before setting any variables (which may call events)
        NamedObjectSaveCodeGenerator.GetPostInitializeForNamedObjectList(null, 
            // There may be a race condition so handle it by to-listing it
            saveObject.NamedObjects.ToList(), 
            currentBlock, saveObject as GlueElement);

        // July 24, 2013
        // Victor Chelaru
        // Why do we initialize here in PostInitialize?  The variable gets set in AddToManagersBottomUp. 
        // I'm going to remove this to see if it causes problems:
        //for (int i = 0; i < saveObject.CustomVariables.Count; i++)
        //{
        //    CustomVariable customVariable = saveObject.CustomVariables[i];

        //    if (!IsCustomVariableAssignedInAddToManagers(customVariable, saveObject))
        //    {
        //        CustomVariableCodeGenerator.AppendAssignmentForCustomVariableInElement(currentBlock, customVariable, saveObject);
        //    }
        //}
        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators
            .OrderBy(item => (int)item.CodeLocation))
        {
            currentBlock = codeGenerator.GeneratePostInitialize(currentBlock, saveObject);
        }
        foreach (ReferencedFileSave rfs in saveObject.ReferencedFiles)
        {
            AssetTypeInfo ati = rfs.GetAssetTypeInfo();

            if (!rfs.IsSharedStatic && ati != null && !String.IsNullOrEmpty(ati.PostInitializeCode))
            {
                currentBlock.InsertBlock(ReferencedFileSaveCodeGenerator.GetPostInitializeForReferencedFile(rfs));
            }
        }
        currentBlock.Line("FlatRedBall.Math.Geometry.ShapeManager.SuppressAddingOnVisibilityTrue = oldShapeManagerSuppressAdd;");
    }

/// <summary>
/// Generate AfterActivity() for the <paramref name="element"/>
/// </summary>
/// <param name="codeBlock">Code block to write the element for.</param>
/// <param name="element">Element to write the code block for.</param>
    public static void GenerateAfterActivity(ICodeBlock codeBlock, GlueElement element)
    {
        #region Loop through all ReferenceFiles to get their post custom activity code

        foreach (ReferencedFileSave referencedFile in element.ReferencedFiles)
        {
            codeBlock.InsertBlock(ReferencedFileSaveCodeGenerator.GetPostCustomActivityForReferencedFile(referencedFile));
        }

        #endregion

        #region Loop through all NamedObjectSaves to get their post custom activity code

        foreach (NamedObjectSave namedObject in element.NamedObjects)
        {
            NamedObjectSaveCodeGenerator.GetPostCustomActivityForNamedObjectSave(element, namedObject, codeBlock);
        }

        #endregion
        
        foreach (PluginManager pluginManager in PluginManagerBase.GetInstances().Cast<PluginManager>())
        {
            CodeGeneratorPluginMethods.GenerateActivityPluginCode(CodeLocation.AfterStandardGenerated,
                pluginManager, codeBlock, element);
        }
    }

    /// <summary>
    /// Localizes the contents (if necessary)
    /// </summary>
    /// <param name="namedObject">Named object</param>
    /// <param name="variableName">Name of the variable</param>
    /// <param name="valueAsObject">Value of the variable (as object)</param>
    /// <param name="valueAsString">Value of the variable (as string)</param>
    /// <param name="customVariable">Established variable</param>
    /// <returns>Localized string, or the default input.</returns>
    public static string MakeLocalizedIfNecessary(NamedObjectSave namedObject, string variableName, object valueAsObject, string valueAsString, CustomVariable customVariable)
    {
        // This code will convert something like
        //      someVariable = "Hello";
        // to
        //      someVariable = LocalizationManager.Translate("Hello");

        // This code gets called on states.
        // If it's a state, then we find the 
        // custom variable that the state represents
        // and pass it as the last argument in the method.
        // We can look at that custom variable to see if it's
        // an AnimationChain

        var shouldTranslate = false;

        if (ObjectFinder.Self.GlueProject != null && 
            ObjectFinder.Self.GlueProject.UsesTranslation && 
            valueAsObject is string && (customVariable == null || customVariable.Type != "Color"))//&& !namedObject.IsAnimationChain)
        {
            if (customVariable != null && customVariable.GetIsAnimationChain())
            {
                // do nothing
            }
            else if (namedObject is { SourceType: SourceType.File })
            {
                if (!String.Equals(variableName, "CurrentChain",
                        StringComparison.OrdinalIgnoreCase) // CurrentChain is used by some FRB types
                    && !String.Equals(variableName, "CurrentChainName",
                        StringComparison.OrdinalIgnoreCase) // and CurrentChainName is used by others...
                    )
                {
                    shouldTranslate = true;
                }
            }
            else if (namedObject is { SourceType: SourceType.Entity })
            {
                EntitySave entitySave = ObjectFinder.Self.GetEntitySave(namedObject.SourceClassType);

                if (entitySave != null)
                {
                    CustomVariable variableInEntity = entitySave.GetCustomVariable(variableName);

                    if (variableInEntity == null || variableInEntity.GetIsAnimationChain() == false)
                    {
                        shouldTranslate = true;
                    }
                }
            }
            else if (namedObject is { SourceType: SourceType.FlatRedBallType })
            {
                if (namedObject.GetAssetTypeInfo() == AvailableAssetTypes.CommonAtis.Text && variableName == "DisplayText")
                {
                    shouldTranslate = true;
                }
            } 
        }

        if(shouldTranslate)
        {
            valueAsString = "FlatRedBall.Localization.LocalizationManager.Translate(" + valueAsString + ")";
        }

        return valueAsString;
    }


/// <summary>
/// Add event generated code for the element
/// </summary>
/// <param name="element">Element to generated code for</param>
    internal static void AddEventGeneratedCodeFileForElement(GlueElement element)
    {

        var fileName = element.Name + ".Generated.Event.cs";
        var fullFileName = GlueState.Self.CurrentMainProject.Directory + fileName;
 
        // the file won't be saved, as we will be doing that by hand.
        ProjectManager.CodeProjectHelper.CreateAndAddPartialGeneratedCodeFile(fileName, false);

        FileWatchManager.IgnoreNextChangeOnFile(fullFileName);
        FileManager.SaveText("// Empty event file - code will be added here if events are added in Glue", fullFileName);
    }

    /// <summary>
    /// Generate AddToManagersBottomUp() method for the <paramref name="element"/>.
    /// </summary>
    /// <param name="codeBlock">Code block to write the element to</param>
    /// <param name="element">Element to be written</param>
    internal static void GenerateAddToManagersBottomUp(ICodeBlock codeBlock, GlueElement element)
    {
        var isEntity = element is EntitySave;
        var isScreen = element is ScreenSave;

        var inheritsFromElement = element.InheritsFromElement();

        var layerArgs = "";

        if (isEntity)
        {
            layerArgs = "FlatRedBall.Graphics.Layer layerToAddTo";
        }

        ICodeBlock currentBlock = codeBlock;

        currentBlock = currentBlock
            .Function("AddToManagersBottomUp", layerArgs, Public: true, Override: inheritsFromElement,
                      Virtual: !inheritsFromElement, Type: "void");

        if (inheritsFromElement)
        {
            currentBlock.Line(isEntity ? "base.AddToManagersBottomUp(layerToAddTo);" : "base.AddToManagersBottomUp();");
        }

        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators
            .Where(item =>item.CodeLocation == CodeLocation.BeforeStandardGenerated))
        {
            codeGenerator.GenerateAddToManagersBottomUp(currentBlock,element);
        }

        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators
            .Where(item => item.CodeLocation == CodeLocation.StandardGenerated))
        {
            codeGenerator.GenerateAddToManagersBottomUp(currentBlock, element);
        }


        if (isScreen && String.IsNullOrEmpty(element.BaseElement))
        {
            currentBlock.Line("CameraSetup.ResetCamera(SpriteManager.Camera);");
        }

        if (!element.InheritsFromElement())
        {
            currentBlock.Line("AssignCustomVariables(false);");
        }

        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators
            .Where(item => item.CodeLocation == CodeLocation.AfterStandardGenerated))
        {
            codeGenerator.GenerateAddToManagersBottomUp(currentBlock, element);
        }
    }

    /// <summary>
    /// Retrieves all code files associated with <paramref name="element"/>
    /// </summary>
    /// <param name="element">Element to retrieve all code files for.</param>
    /// <returns>Stack of file paths.</returns>
    public static List<FilePath> GetAllCodeFilesFor(GlueElement element)
    {
        var directory = FileManager.GetDirectory(GlueCommands.Self.GetAbsoluteFileName(element.Name + "/", false));

        var foundCsFiles = FileManager.GetAllFilesInDirectory(directory, "cs")
            .Select(item => new FilePath(item)).ToList();

        for (var i = foundCsFiles.Count - 1; i > -1; i--)
        {
            FilePath file = foundCsFiles[i];
            var relativeFile = FileManager.MakeRelative(file.Original).Replace('/', '\\');
            var isValid = relativeFile.StartsWith(element.Name) && relativeFile[element.Name.Length] == '.';

            if (!isValid)
            {
                foundCsFiles.RemoveAt(i);
            }
        }

        if(element is EntitySave { CreatedByOtherEntities: true })
        {
            var strippedName = FileManager.RemovePath(element.Name);

            // This also has a factory, so check for that.
            var fullName = GlueState.Self.CurrentGlueProjectDirectory + "Factories/" + strippedName + "Factory.Generated.cs";

            foundCsFiles.Add(fullName);
        }

        return foundCsFiles;

    }

    private static void GeneratePauseIgnoringActivity(ICodeBlock codeBlock, GlueElement saveObject)
    {
        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators)
        {
            codeGenerator.GeneratePauseIgnoringActivity(codeBlock, saveObject);
        }

        foreach (NamedObjectSave namedObject in saveObject.NamedObjects.Where(namedObject => namedObject.IgnoresPausing))
        {
            NamedObjectSaveCodeGenerator.GetActivityForNamedObject(namedObject, codeBlock);
        }
    }

    /// <summary>
    /// Generated UnloadStatic() method for the <paramref name="element"/>
    /// </summary>
    /// <param name="codeBlock">Code block to write the element to</param>
    /// <param name="element">Element to be written</param>
    /// <returns><paramref name="codeBlock"/>.</returns>
    internal static ICodeBlock GenerateUnloadStaticContent(ICodeBlock codeBlock, GlueElement element)
    {
        ICodeBlock currentBlock = codeBlock;

        #region Generate UnloadStaticContent

        // Vic says - originally the code would only
        // generate UnloadStaticContent for entities IF they had
        // static content.  Well, we want to simplify the interface 
        // so all entities will always generate this method.  That way
        // all Entities can just clone elements in the loaded data.

        if (element is EntitySave)
        {
            currentBlock = currentBlock
                .Function("UnloadStaticContent", "", Public: true, Static: true,
                          New: element.InheritsFromElement(), Type: "void");

            // We only want to unload if this isn't using global content
            // If so, then unloading should be a no-op
            if (!element.UseGlobalContent)
            {
                foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators)
                {
                    currentBlock = codeGenerator.GenerateUnloadStaticContent(currentBlock, element);
                }

            }
            else
            {
                currentBlock.Line("// Intentionally left blank because this element uses global content, so it should never be unloaded");
            }
        }

        #endregion
        return codeBlock;
    }

    /// <summary>
    /// Generates ConvertToManuallyUpdated() method for the <paramref name="element"/>
    /// </summary>
    /// <param name="codeBlock">Code block to write the element to</param>
    /// <param name="element">Element to be written</param>
    /// <param name="reusableEntireFileRfses">Reusable RFSes.</param>
    internal static void GenerateConvertToManuallyUpdated(ICodeBlock codeBlock, GlueElement element, Dictionary<string, string> reusableEntireFileRfses)
    {
        var hasBase = element.InheritsFromElement();

        ICodeBlock currentBlock = codeBlock;

        currentBlock = currentBlock
            .Function("ConvertToManuallyUpdated", "", Public: true, Override: hasBase, Virtual: !hasBase,
                      Type: "void");

        if (hasBase)
        {
            currentBlock.Line("base.ConvertToManuallyUpdated();");
        }

        if (element is EntitySave)
        {

            // It's possible that an Entity may be converted to ManuallyUpdated before
            // any Draw calls get made - this means that UpdateDependencies will never get called.
            // This should happen before the other manual updates are called so that everything is positioned
            // right when verts are created.
            currentBlock.Line("this.ForceUpdateDependenciesDeep();");

            if (element.InheritsFromFrbType())
            {
                AssetTypeInfo ati = AvailableAssetTypes.Self.GetAssetTypeFromRuntimeType(element.BaseElement, element);

                if (ati != null)
                {
                    currentBlock.Line(ati.MakeManuallyUpdatedMethod + ";");
                }
            }
            else
            {

                // Convert the Entity itself to manually updated
                currentBlock.Line("FlatRedBall.SpriteManager.ConvertToManuallyUpdated(this);");
            }
        }

        foreach (ReferencedFileSave rfs in element.ReferencedFiles)
        {
            ReferencedFileSaveCodeGenerator.GenerateConvertToManuallyUpdated(currentBlock, rfs);
        }

        NamedObjectSaveCodeGenerator.WriteConvertToManuallyUpdated(currentBlock, element, reusableEntireFileRfses);
    }

    /// <summary>
    /// Generates the methods for the <paramref name="element"/>.
    /// </summary>
    /// <param name="codeBlock">Code block to write the methods to.</param>
    /// <param name="element">Element to write the code block for.</param>
    private static void GenerateMethods(ICodeBlock codeBlock, GlueElement element)
    {
        ICodeBlock currentBlock = codeBlock;

        GeneratePostInitialize(codeBlock, element);
        GenerateAddToManagersBottomUp(currentBlock, element);
        GenerateRemoveFromManagers(currentBlock, element);
        GenerateAssignCustomVariables(codeBlock, element);
        GenerateConvertToManuallyUpdated(currentBlock, element, ReusableEntireFileRfses);
        GenerateLoadStaticContent(currentBlock, element);
        currentBlock = GenerateUnloadStaticContent(currentBlock, element);

        if(element is ScreenSave)
        {
            GeneratePauseThisScreen(currentBlock, element);

            GenerateUnpauseThisScreen(currentBlock, element);
        }

        GenerateUpdateDependencies(currentBlock, element);

        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators)
        {
            // I see no reason to take the code block
            //currentBlock = codeGenerator.GenerateAdditionalMethods(currentBlock, element);
            codeGenerator.GenerateAdditionalMethods(currentBlock, element);
        }

        currentBlock.Line("partial void CustomActivityEditMode();");

        foreach (PluginManager pluginManager in PluginManagerBase.GetInstances().Cast<PluginManager>())
        {
            CodeGeneratorPluginMethods.GenerateAdditionalMethodsPluginCode(pluginManager, codeBlock, element);
        }

    }
    
    /// <summary>
    /// Generate PauseThisScreen() for the <paramref name="element"/>.
    /// </summary>
    /// <param name="codeBlock">Code block to write the methods to.</param>
    /// <param name="element">Element to write the code block for.</param>
    private static void GeneratePauseThisScreen(ICodeBlock codeBlock, GlueElement element)
    {
        ICodeBlock methodBlock = codeBlock.Function("public override void", "PauseThisScreen", "");

        foreach(ElementComponentCodeGenerator generator in CodeGenerators)
        {
            generator.GeneratePauseThisScreen(methodBlock, element);
        }

        methodBlock.Line("base.PauseThisScreen();");
    }

    /// <summary>
    /// Generate UnpauseThisScreen() for the <paramref name="element"/>.
    /// </summary>
    /// <param name="codeBlock">Code block to write the methods to.</param>
    /// <param name="element">Element to write the code block for.</param>
    private static void GenerateUnpauseThisScreen(ICodeBlock codeBlock, GlueElement element)
    {
        ICodeBlock methodBlock = codeBlock.Function("public override void", "UnpauseThisScreen", "");

        foreach (ElementComponentCodeGenerator generator in CodeGenerators)
        {
            generator.GenerateUnpauseThisScreen(methodBlock, element);
        }

        methodBlock.Line("base.UnpauseThisScreen();");
    }

    /// <summary>
    /// Generate UpdateDependencies() for the <paramref name="element"/>.
    /// </summary>
    /// <param name="codeBlock">Code block to write the methods to.</param>
    /// <param name="element">Element to write the code block for.</param>
    private static void GenerateUpdateDependencies(ICodeBlock codeBlock, GlueElement element)
    {
        // screens will need this too:
        var innerBlock = new CodeBlockBase();

        foreach(ElementComponentCodeGenerator generator in CodeGenerators)
        {
            generator.GenerateUpdateDependencies(innerBlock, element);
        }

        if(innerBlock.BodyCodeLines.Any())
        {
            ICodeBlock methodBlock = codeBlock.Function("public override void", "UpdateDependencies", "double currentTime");

            methodBlock.InsertBlock(innerBlock);

            methodBlock.Line("CustomUpdateDependencies(currentTime);");

            codeBlock.Line("partial void CustomUpdateDependencies(double currentTime);");
        }
    }

    /// <summary>
    /// Generate RemoveFromManagers() for the <paramref name="element"/>.
    /// </summary>
    /// <param name="codeBlock">Code block to write the methods to.</param>
    /// <param name="element">Element to write the code block for.</param>
    private static void GenerateRemoveFromManagers(ICodeBlock codeBlock, GlueElement element)
    {
        if (element.InheritsFromElement())
        {
            codeBlock = codeBlock.Function("public override void", "RemoveFromManagers", "");
            codeBlock.Line("base.RemoveFromManagers();");
        }
        else
        {
            codeBlock = codeBlock.Function("public virtual void", "RemoveFromManagers", "");

        }

        if (element is EntitySave entitySave)
        {
            if (entitySave.InheritsFromFrbType())
            {
                AssetTypeInfo ati = AvailableAssetTypes.Self.GetAssetTypeFromRuntimeType(element.BaseObject, entitySave);

                if (ati != null)
                {
                    if (entitySave.CreatedByOtherEntities && !String.IsNullOrEmpty(ati.RecycledDestroyMethod))
                    {
                        codeBlock.Line(ati.RecycledDestroyMethod + ";");
                    }
                    else if(ati.DestroyFunc != null)
                    {
                        codeBlock.Line(ati.DestroyFunc(entitySave, null, null));
                    }
                    else
                    {
                        codeBlock.Line(ati.DestroyMethod + ";");
                    }
                }
            }

            else if (!entitySave.InheritsFromElement())
            {
                codeBlock.Line("FlatRedBall.SpriteManager.ConvertToManuallyUpdated(this);");
            }

            if (entitySave.ImplementsIWindow && !entitySave.GetInheritsFromIWindow())
            {
                codeBlock.Line("FlatRedBall.Gui.GuiManager.RemoveWindow(this);");
            }
        }

        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators)
        {
            codeGenerator.GenerateRemoveFromManagers(codeBlock, element);
        }
    }

    /// <summary>
    /// Generate AssignCustomVariables() for the <paramref name="element"/>.
    /// </summary>
    /// <param name="codeBlock">Code block to write the element to</param>
    /// <param name="element">Element to write to the code block.</param>
    private static void GenerateAssignCustomVariables(ICodeBlock codeBlock, GlueElement element)
    {
        var inherits = !String.IsNullOrEmpty(element.BaseElement) && !element.InheritsFromFrbType();

        
        if (inherits)
        {
            codeBlock = codeBlock.Function("public override void", "AssignCustomVariables", "bool callOnContainedElements");
            codeBlock.Line("base.AssignCustomVariables(callOnContainedElements);");
        }
        else
        {
            codeBlock = codeBlock.Function("public virtual void", "AssignCustomVariables", "bool callOnContainedElements");
        }

        // call AssignCustomVariables on all contained objects before assigning custom variables on "this"
        ICodeBlock ifCallOnContainedElements = codeBlock.If("callOnContainedElements");

        var listOfItems = element.NamedObjects.Where(item=>
            item.IsFullyDefined &&
            !item.IsDisabled &&
            item.Instantiate &&
            !item.SetByContainer  
            ).ToList();
     
        GenerateAssignmentForListOfObjects(codeBlock, element, ifCallOnContainedElements, listOfItems);
  
        foreach (CustomVariable customVariable in element.CustomVariables)
        { 
            CustomVariableCodeGenerator.AppendAssignmentForCustomVariableInElement(codeBlock, customVariable, element);
        }

        EventCodeGenerator.GenerateAddToManagersBottomUp(codeBlock, element);
    }

    /// <summary>
    /// Generate AssignCustomVariables() for the <paramref name="element"/>.
    /// </summary>
    /// <param name="codeBlock">Code block to write the element to</param>
    /// <param name="element">Element to write to the code block.</param>
    /// <param name="ifCallOnContainedElements">Code block that is utilized if subitems exist in the stack.</param>
    private static void GenerateAssignmentForListOfObjects(ICodeBlock codeBlock, GlueElement element, ICodeBlock ifCallOnContainedElements, List<NamedObjectSave> listOfItems)
    {
        foreach (NamedObjectSave item in listOfItems)
        {
            if (item.DefinedByBase == false && item.SourceType == SourceType.Entity)
            {
                NamedObjectSaveCodeGenerator.AddIfConditionalSymbolIfNecesssary(ifCallOnContainedElements, item);

                ifCallOnContainedElements.Line(item.InstanceName + ".AssignCustomVariables(true);");
                NamedObjectSaveCodeGenerator.AddEndIfIfNecessary(ifCallOnContainedElements, item);
            }


            NamedObjectSaveCodeGenerator.AddIfConditionalSymbolIfNecesssary(codeBlock, item);

            ICodeBlock innerBlock = codeBlock;
            if(item.SetByDerived)
            {
                innerBlock = codeBlock.If($"{item.InstanceName} != null");
            }
            NamedObjectSaveCodeGenerator.AssignInstanceVariablesOn(element, item, innerBlock);


            var containedItems = item.ContainedObjects.Where(containedObject =>
                containedObject.IsFullyDefined &&
                !containedObject.IsDisabled &&
                containedObject.Instantiate &&
                !containedObject.SetByContainer &&
                !containedObject.SetByDerived
                ).ToList();

            GenerateAssignmentForListOfObjects(codeBlock, element, ifCallOnContainedElements, containedItems);
            NamedObjectSaveCodeGenerator.AddEndIfIfNecessary(codeBlock, item);

        }
    }

    /// <summary>
    /// Returns <see langword="true"/> if the variable is handled by a custom code generator.
    /// </summary>
    /// <param name="customVariable">Custom variable to check</param>
    /// <param name="element">Element to check that the <paramref name="customVariable"/> belongs to.</param>
    /// <returns><see langword="true"/> if the variable is handled by a custom code generator.</returns>
    internal static bool IsVariableHandledByCustomCodeGenerator(CustomVariable customVariable, GlueElement element)
        => CodeGenerators.Any(codeGenerator => codeGenerator.HandlesVariable(customVariable, element));

    #endregion
}
